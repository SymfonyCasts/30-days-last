# HTML Dialog

Coming soon...

Welcome to day 19. Today we're going to celebrate a little-known HTML element that just absolutely rocks when it comes to building modals, the dialog element. Open up the templates slash voyage slash index.html template. For the h1, I'm going to paste what I just added is just an h1 and a button for new voyage. Then at the bottom, I'll remove this old button we have. So nothing special here. It just adds a new button. If I go to the right page, there it is. But it's a button doesn't do anything at nothing impressive. Now back over here, right after the button, add a dialog element. Inside I will proclaim I am a dialog. Then also add an open attribute. So when we refresh, something really interesting happens. We get this little element and it's, notice it's kind of horizontally positioned and kind of vertically positioned a bit and it's positioned absolute on the page. A dialog is a special element designed for modals or really any dialog, like a dismissive alert or any sub window. It's like a normal HTML element, but with a bunch of superpowers that we're going to see today. But first let's make it prettier. Back in the template, I'll paste over that dialog. Again, this is something that you can get from, you can adapt from Flow Byte or have AI help you, but there's nothing really special. I still have the dialog. It's still open. And notice the classes aren't anything very special. I have a width set on it, but I don't have to worry about the absolute positioning or anything like that because that's just built into the element. And then most of this here is just some hard coded content to get us started. The result is awesome. It looks beautiful already. However, the close button doesn't close yet. So let's fix that. This will be the first time we see, we'll see the first superpower right now for dialog elements. So here's my button and I'm going to add a form method equals dialog around this. So there's nothing special about this button. It's just a normal button, but this form method equals dialog is the key. And now when you click X, it goes away. But to really make the dialog element shine, we're going to need a bit of JavaScript.  So head up to assets controllers and create a new file called modal controller.js. And I will cheat, steal some content from another controller and clear it out. This controller is going to be really simple. First I'm going to create a static target equals dialog so that we can find the actual dialog element really easily inside of this controller. And then we're going to have an open method. And here we'll say this.dialogTarget.show. This is another superpower of the dialog element. It has a show method. So built into it is this idea of showing and hiding. To use this over an index.html twig, we're actually going to put the data controller around this div that holds the button and the dialog. So we'll say data-controller equals modal. And then on the button, we'll say data-action equals modal.open. And then the last thing we need here is to set this up as a target. So I'm going to remove the open so it starts closed. We'll say data-modalTarget equals dialog. All right. So now it starts closed. We don't see it at all. And when we click, it's open, close, open, close. All right. So dialog elements actually have two modes. They're normal mode and a modal mode, which is actually much more useful. To use the modal mode instead of show, it's just showModal. Now when we click, it still opens, but there's some subtle differences here. The first is that I can close it when I hit escape. The second is that there's an overlay. Watch. When I click this, the screen will get just a little bit darker. Do you see that? The way that's added, so yeah, the dialog has just handled it for us. And the way that's added, if we find the dialog element, there it is, is it has a pseudo element called backdrop. So it takes care of adding the backdrop for us. And yes, if we want to, we can style that, and I do want to style that. So over here, find the dialog element, and at the end, thanks to Tailwind, we can actually style that backdrop pseudo element directly. We can say backdrop colon, and then we'll say how about bg slate 600, and then backdrop colon opacity 80 to just give it a little dim out effect. So watch the effect here.  That is starting to feel really, really nice. All right, so I want to make this perfect. We're getting close, but we're not quite there yet. So one thing the dialog element doesn't... One thing the dialog element doesn't handle for you is the page still scrolls, which is kind of not the normal behavior we expect. So to fix this, over in the open method, we can say this dot, we can say document dot body to get the body element, dot class list, dot add, and we'll add overflow hidden. So we have to handle that ourselves one time, but the result works really nicely. Now of course, if we close it right now, I still can't scroll because we need to remove that. So to do that, let's copy the open method and make a close method. So call it close. In this case, we can call the close method on the dialog, and we will remove the overflow hidden. Now there's just one problem with this. We're not actually calling the close method. When we hit X or we hit escape, the dialog is closing, yes, but I still can't scroll because we're not actually calling this close method. Fortunately, the dialog element has our back here again. Whenever a dialog element closes for any reason, it dispatches an event called close, and we can listen to that. So check this out. Whenever on our dialog element, we're going to add a data dash action.

="CLOSE arrow modal Close). So now, no matter how the dialog closes, like I'll hit Escape, we can now scroll because our close method on our controller was called. Alright, what else can we add here? How about blurring the background, that would be kind of cool. Now, you might think that you can add a little backdrop blur, that doesn't seem to work, but what we can do is blur the body itself. So we're already adding some classes to the body, so let's add a blur-sm and remove the blur-sm. Let's check out the effect here, that is really cool. Alright, so one other thing that the dialog element doesn't handle is clicking outside. If I click outside here, it doesn't close. So fortunately, that's a really quick one-time fix. Up on the root element of our controller, you know what, actually, let me put it down here. I'm actually going to add it right here. the modal, and it is going to be click modal, and then we're going to say click outside. Now, this might seem weird because this is going to trigger whenever we click this element or any element inside. So to see how this works, let's go and write that method. So we'll click outside, we'll grab the event, and we'll say if event.target equals this.dialogTarget, then this.dialogTarget.close, or you could also just say this.close. So it turns out, what we're checking here to see, event.target is going to be the actual individual element that received the click. And it turns out the only way you can click the dialog element itself is if you click the backdrop. If you click anywhere else inside, it's going to be one of these things that receives the click. So it's a little bit kind of a tricky three lines of code, but the result is perfect. Click in here, no problem. Click out there. We are good. All right, so we are really, really close now, but I'm not happy yet. I want to have an animation in, cool? Now we could use a CSS transition for that. We would need to start the dialog at opacity zero, unhide it, then transition its opacity up to 100. But I'm going to use a different trick called a CSS animation. I know, transitions, animations.  An animation is something you can apply to an element and it will just animate forever. Or you can make it animate just once. Like we can make this button just animate up and down forever. One of the nice things about animations is that you can make animations that only happen once and they won't trigger until the element becomes visible on the page. So we can make an animation that goes from opacity zero to opacity 100 and that'll trigger just naturally as soon as we open our dialog. So Tailwind does have some built-in animations, but it doesn't have one for fading in. So we're going to add it. So down in tailwind.config.js, I want to paste over this theme extend spot here. So this is mostly just CSS animation stuff, but we're going to have a new animation called fade in, and it's going to go from opacity zero to opacity one over a half a second. To use this, we'll go over on our dialog element, and it doesn't matter where, but right here I'll say animation-fadein. And that did not work. Why now? What did I do wrong? Oh, I always do this. Actually, I was supposed to be animate-fadein. And now, oh, beautiful. It comes in nice and slow. Could we fade out? Sure. I'm actually not going to do that because I like being able to close this and getting back to my work underneath it as quickly as possible. All right, there is one last detail that I want to bring up, and it has to do with turbo page snapshots. When we added view transitions in app.js, we actually disabled this feature called page cache. The reason we disabled it is apparently it doesn't play nicely in some cases with view transitions. It probably won't be a problem in Turbo 8 since view transitions come standard anyway. So what view transitions are going to do is, for example, if we click to planets and... With the snapshot cache, the moment you click off of a page, it's going to take a snapshot of this page. Then if we click the back button, it'll be instant, boom, because it actually just uses the version from your cache. There's more to it than that, but that is a good explanation. Now when you do...  With page snapshots, the one thing you need to worry about is removing any temporary elements from the page before the snapshot can be taken, like flash toast messages or modals. Because when you go back to the page, you don't want a toast notification to be sitting up here. Now the way that we normally solve this is in __flashes.html-twig. We add a data turbo temporary. That tells Turbo to remove this element before it takes the page snapshot. However, in this case, adding this is not going to be enough. I'll actually show you. Here's the problem I'm trying to fix. If we open a modal right here and I go back and I go forward, we're in this really weird state. It looks like the dialogue is gone, but we still can't scroll and the page is blurred. That's because we need to do more than just hide the dialogue. We need to actually remove these classes from the body. What we really need is before Turbo takes that snapshot, we need our close method to be called. We can totally do that. In index.html-twig, on the dialogue element, nope. On the root element, though it could go anywhere, I'm going to add data action equals. Right before Turbo takes its snapshot, it dispatches an event called Turbo before cache. We can listen to that and then call modal close. The only other detail here is that the Turbo before cache event isn't dispatched on events. It's not dispatched on this element or on this element. Listening here is not going to work. It's dispatched on the window. It's a global event. Fortunately, Turbo gives us a way to listen to global events by adding at window. It's a little bit technical there, but it's a one-time fix because now we can open the modal, go back, forward, and the page works beautifully. Okay. Today was a huge day. Congratulations, but look what we accomplished. This beautiful modal system that we have total control over. Tomorrow's going to be just as big of a day because we're going to bring this modal to life with real dynamic content and forms inside of it. See you then.
