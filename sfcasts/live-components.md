# Live Components

Coming soon...

Happy Day 27 of Last Stack! We have accomplished a lot over the first 26 days with just three letters of Last Stack – asset mapper, stimulus, and turbo. Today we finally learn about the L – live components. Live components let us take a twig component, then automatically re-render it via Ajax as the user interacts with it. So today we're going to focus on this global search. When we click this right now, absolutely nothing happens. What I want to do is open up a modal with a search box, and as we type into it, we have a live search. So let's start inside of templates slash base dot html twig, and I will search for search. Perfect. Here we go. So here is that fake-looking input right there. So I'm going to add a twig modal. Let's do a close button equals true, and then a twig block name equals trigger, and we'll put this fake input inside of there as a trigger. And then to actually make this open, the modal will say data dash action equals modal open. Cool. So there's no modal content yet, but if we refresh, nothing changes. The only thing that's visible inside of our modal is the trigger. For the modal content, after the twig block, I'm just going to paste in a div. Nothing special here. It's just a search input. All right, so we go over here and try this on click. Nothing happens. And the way I debug this is I inspect element, open up my console, and when I click, notice there's no log here that says the action's being triggered. So I've got something wrong with my action. And the problem is that, you may have spotted it, we added our data action to a div. And unlike a button or a form, a div doesn't have a native action. So if we want to add a data action to a div, we need to specify the event. So click arrow. And now, got it. And notice, it auto-focuses the input. That's just a feature of dialogs. That's just one of the things that they do. But this is more padding than I want. So in components modal.html twig, it's okay, we just need to make our modal a little bit more flexible. What I'm looking at here is this P5. I usually want that.  I don't want it in this case. So let's add a third prop here called padding equals P5. I'll copy that. And down here, just curly, curly padding. And over in base.html twig on our modal, we can now say padding equals empty quotes. All right, let's check that result. Now awesome. It's a little bit tighter and neater looking. All right, to actually get the results in here, we could treat this just like our data tables set up behind. We could put a turbo frame with the results right here. And then make the input submit into that frame. But another option is to build this into a live component. So that's what we're gonna do. And before we actually talk about live components, we're first just going to move the modal contents into a twig component. So in templates component, create a new file called search site.html.twig. I'll add a div with curly, curly attributes. And inside, let's just go steal the entire body of the modal. I'll paste it in here. Perfect. Now over in base.html twig, it's easy, right? Base.html.twig, colon, search site, done. And over here, we've got the same results. Now to render the results themselves down here, this is where having a twig component is gonna come in handy. One thing we could do is somehow get the voyages that we wanna show instead of base.html twig, which is a little tricky, and then pass them into our search site as a prop. But one of the advantages of twig components is they can fetch their own data. They can be standalone. So to do that, we need a twig class for this. So in source twig components, create a new PHP class called search site. And the only thing this needs to become a twig component is an attribute called as twig component. So this is exactly what we saw inside of our button class. And as I mentioned earlier, one of the superpowers of twig components is their services, and they can auto-wire other services like voyage repository, voyage repository. Now to provide the data, I'm gonna create a new function down here called voyages, which is going to return an array. And really, it's going to return an array of voyages, so I'll use phpDoc for that.  And inside, I'll say return this arrow voyage repository or arrow find by search. It's the same method we're using on our homepage. And for the query, I'll pass null search planets, empty array, and limit about 10 results. So we don't have this. The search query is not dynamic yet, but we do have this voyage method, and we can use that inside of our template. So I'll start with a little bit of styling. And then it's just normal twig code for voyage in this, that's our component object, .voyages. Do an end for, and for the middle, I'll paste that in. Nothing special here though, just an anchor tag that links to it, an image tag, and some information. And when we refresh, ah, we've got it. Our standalone twig component is coming in handy, but it doesn't do anything yet. So this is where live components is going to come in handy. Let's get it installed at your terminal run composer, require symphony slash UX live components. To upgrade our twig component to a live component, we only need to do two things. First, it's as live components, and the second, you need to use this default action trait. It's an internal, not important detail. You just need to remember to have that use statement. Now at this point, nothing changes. It's still a twig component, and we haven't added any new superpowers to it.

So one of the key concepts with a live component is that you can add a property and allow the user to change that property on the front end. So for example, let's create a public string query, which will be our search string. And then down here, we'll use that with this arrow query. Now to make the user able to modify this property, we need to give it an attribute called liveProp with writeable true. Finally, to attach this property to this input here so that it changes as the user types, we add data-model equals query. That's it. Check it out over here. Refresh. We get all the results. And when we type, it works. It even has built-in debouncing, which we had to build by hand earlier. And behind the scenes, it's making an AJAX request, populating the query property with this string, and just re-rendering the tweak template. And now that we have this working, I don't think we need to load all the results on page load anymore. So look, it's just PHP, so it's easy. If not this arrow query, then we'll return empty results. And in search site, we'll just put an if statement around this. If this.voyages is not empty, then we'll render that with the end if on the bottom. Now those of you that are sticklers for details, yes, this.voyages, we're calling that twice. So that's going to call that method twice. But there are ways around this. The way I like to use it is something called expose in template. I won't show it here, but there's an easy solution to avoid that double query. All right. So I want to make this perfect, as you know. So one thing that kind of bothers me is the position of this. It looks a little low down here when it's empty. And as we type into it, it kind of jumps around a little bit. Which is just kind of weird. So in this one case, I want to fix the position of this kind of near the top of the page. So in modal.html twig, let's add one last piece of flexibility to our modal components. Let's call it fixed top equals false. And for that fixed top, we'll go to the end of the class. And we'll call that fixed top.  And for that fixed top, we'll go to the end of the class list on the dialog. And we'll say if fixed top, then we'll give a specific mt-14, else we'll do nothing. Normally we let the margin of the dialog just be figured out. Then over in base.html twig, on our modal, let's actually break it down a little bit. And if we break this onto multiple lines as well, we'll say colon fixed top equals true. And now, ah, really nice. So no more jumping around as we get those results. All right, what else? Pressing up and down on my keyboard to have this kind of scroll up and down is something that we'll save for later. But I do want to make one thing, one change. So right now, if I search inside of here and then click out of here and then change pages, not surprisingly, when we open the search back up, it's empty. It doesn't need to be. It'd be really cool if it remembered the search. To do that, we can take advantage of a feature in Turbo. So over in base.html twig, on this modal, we're going to add data turbo temporary, permanent, that tells Turbo to keep this on the page as it's navigating and permanently. And when you use this, you also need an ID. So how about global search? All right, let's try this now. So I'm going to open the search. We're going to search for something, click off of it, go to the home page, click back again. How nice is that? All right, last thing. As you can see up here, I'm advertising. We can open this with a keyboard shortcut. That doesn't work yet, but this is something that just works with stimulus. It's easy. So on our modal, we're just going to add a data action. And stimulus has built in support for doing things on key down. So you can say key down dot, and then whatever the key is that you want, like hit K. Or in this case, what we want is control plus K. But if we just did this, it would only happen if the control plus K was on the right. So we're going to add a data action.  But if we just did this, it would only happen if the control K happened when this modal was focused. We want this to happen everywhere. So we're going to say at window. So we're listening to the key down event on control K globally, no matter where it's actually triggered. And then we'll say arrow modal consign open. And I'm going to copy that and do a space and paste it. And we'll also do key down meta dot plus K. Meta is the word for the Apple key, the special command key on Apple. All right, now check this out. Now move over and it works. Oh, I love that. Done. Live components can also be loaded lazily via AJAX. It's not really useful in this case, but it's called defer. So if we just add a defer attribute onto here, we won't notice any difference when we refresh the page. But actually the search site was not rendered on page load and instead was rendered via AJAX immediately. We can see that down here, there's already one AJAX call to go fetch that. So not particularly useful in our case because this search site is so lightweight. But if you have something that's a little heavier and you don't want it to sit on your page, add defer. All right, tomorrow we're going to use live components on a form to add real time validation and solve the age old pesky problem of dynamic or dependent form fields.
