# Modals

Coming soon...

Yesterday we built a killer modal system thanks to the dialogue element. With just this markup right here and our small stimulus controller, we're really dangerous. So let me tell you about today's goal, which is probably gonna be one of the biggest, most important days in the entire series. When I click new voyage, I want it to pop up in this modal, but Ajax load the real form behind it. And when we click submit on that form, I want it to all happen inside of the modal like it should be. We're also gonna add 10 other nice details to this to make it really shine. And more than that, I wanna create a reusable system so we can load any form into a modal with nearly zero effort. So to get this going, we're going to copy the entire modal markup. There we go. And then go into base.html twig and all the way at the bottom, right before the closing body tag, paste that. Now back in index.html twig, let's remove the dialogue and then we don't need the modal data controller stuff anymore. So this is now just a normal H1 and a normal button that doesn't do anything. In a base.html twig, we'll kind of do the opposite. So we'll remove the button and the H1 and then the class on the div. So now it's just a normal div and the only thing inside of it is a dialogue element. Now for the magic touch. Mm. Take out the guts of the dialogue and only keep these two divs. These help kind of give you padding and nice scroll behavior. Inside the actual guts, add a turbo frame with id equal modal. That was a power move. On every page, we now have a turbo frame modal that lives inside of a modal that we can dynamically load content into. Watch this. Over on the index page, change this new voyage to an a tag and then set it to normal, set its href to app voyage new. So it's a normal tag that would take us to the new page. But now add data turbo frame equals modal. So thanks to this, when we refresh and click, it doesn't navigate us, it actually navigates into this modal. But you see, nothing happened.  It did go to the voyage slash new page, but if I open that up in a new tab, there's no modal turbo frame on this page. Well, actually there is. There is at the very bottom of the page, there's the empty turbo frame modal. So right now when we click that link, it does work, but the turbo frame stays empty. To fix this temporarily, in new.html twig, let's add a turbo frame. Turbo frame ID equals modal. And on the bottom, add the closing tag. So watch, check this out. When I click now, yes, look at this. Inside the turbo frame, we have the form. The modal isn't opening yet, but it's ready. Now, before we figure out how to open the modal, we have a problem and an opportunity. If we went directly to the new voyage page, we actually have two turbo frame ID equals modal elements on the page, which is kind of an invalid thing to do. And also, even though I want to have the ability to load this inside of a modal, I also want it to behave like normal if we go to the page directly. Watch right now, if I fill this out successfully and save, weird things happen. I submitted that into a turbo frame, and it tried to load the turbo frame with the empty modal on the index page. So that's not what I want. I want this page to behave like normal when I go to it directly. So we're going to do this with a trick. In new.html.twig, remove the turbo frame and extend a new base class called modal base. Ooh, I'm then going to copy that name and in the templates directory, create modal base.html.twig. This is going to have an extends tag that's dynamic. So if app.request.headers.getTurboFrame, equals modal. So if an AJAX request is being made to this page from the modal turbo frame, then extend a new modal frame.html.twig. Else, we're going to extend the normal base.html.twig. So if we go to the page like normal, it's going to extend base.html.twig. There's no turbo frame on this. It's completely normal. But now, let's create that modal frame.html.twig. Copy that. In templates, let's create that. This is going to be really simple.  Turbo frame ID equals modal. And inside of it, we're going to render block body and block. So if we make a turbo frame request to this page, the only thing that's going to return from the server is this turbo frame right here with the page's content inside. So that solves our problem. And it means that if we want a page to be able to load its form into a modal, the only line we're going to need to change is right here. And we'll see that tomorrow when we start loading the edit form in the frame. But first, we're back to the situation where when we click this link, if I go down here and open my modal and find the turbo frame, it is loading the content into the turbo frame, but the modal isn't opening. So how can we do that? Well, I have two requirements for opening the modal. The first is that I want it to be super easy to open. If HTML appears inside of this turbo frame, no matter how it's being added, I want the system to be smart enough to see that and open the modal itself. And second, I want the modal to open instantly. I don't want to click this button and then have to wait for 500 milliseconds before I see the modal. It's not a good user experience. So for part one, opening this modal as soon as there's content in the turbo frame, we're going to use a little trick inside of our stimulus controller. So let me close the modal base in the new template. And in base.html twig, I'm going to make this turbo frame a target. Data modal target equals dynamic content. So the goal is going to be, if a modal has this target, if HTML gets inside of this target for any reason, we're going to notice that and open up the modal. To do that in modal controller, let's add that target. And then I'm going to copy in the most complex code that we're going to see from this tutorial. Now this looks complex, but the idea is really simple. If we have a dynamic content target, what this code does here is it just watches that element for any changes of any kind.  And anytime any change is made to that, it's going to call our callback. And our logic here is really simple. It's going to look to see if our dynamic content target has any HTML. And if it does, it opens it. And if it doesn't, it closes it. It's that simple. In disconnect, we kind of turn off that system. And we also add a nice little thing that says, if for some reason the dialogue target is removed from the page, for some reason this controller element is removed from the page, we'll make sure that we close the dialogue target and clean up after ourselves. So the result of this is pretty incredible. I'm going to refresh the page and check this out. I'm going to edit this as HTML and say, will this open? Watch, boom, it opens.

It saw that change and it opened the content. Watch, if I remove that, it closes. And of course, most importantly, when we click the link, we see the form. All right, so let's try to submit this and something goes wrong. It went to a page that didn't have a TurboFrame ID equals modal. And that's because the response was an error. If we look down here on the web debug toolbar, there was a 405 status code. Let's open that up. So it says no route found for post slash voyage, which is weird because we're submitting the new voyage form. But here's the problem. When you generate, when I generated the crud for my voyage system, it generated form elements that don't have an action attribute. That's fine when you were on that page, because it means it submits right back to the same URL. But as soon as you start embedding your forms in other places, you need to be responsible and always set the action attribute to do that, open up our source controller, the voyage controller. And at the bottom of this, I'm going to paste in a really simple private method. That's going to handle this for us. Okay. To add the use statement. So we can pass a voyage or not pass a voyage. And all this does is create our normal voyage form, but it sets the action attribute. If the voyage has an ID, it sets the action to the edit page else it sets it to the new page. So thanks to this up in the new action, we can say this arrow create voyage form voyage, and I'll copy that line because we need the exact same thing down here in edit. Perfect. All right. So now I don't even need to refresh. I'm just going to open the modal, save, and it works. It's submitted. And we got the response right back inside the modal because of course that's the whole point of a turbo frame. It keeps the navigation right inside this area. Now, before we talk about what happens on success, let's perfect this. My second requirement for the opening the modal was that it needed to open immediately over in our new action. Add a sleep equals two to mimic our site being so cool that it's being slammed by traffic.  Now, when we hit the button click, nothing happens. No user feedback at all until the Ajax request actually finishes. It's not good enough. Instead, I want the modal to open immediately with some loading content. To do this over in the modal controller, we're going to add a new target called loading content. So the idea is that in our actual HTML in a second, we will define the, what we want the loading content to look like inside of our modal. Then down here, we're going to create a new method called showLoading. And if this.dialogTarget.open, so if we're already open, we don't need to show the loading, I'm just going to return. Otherwise say this.dynamicContentTarget. So in our case, this is going to be the turbo frame that we're waiting to load the Ajax into. .innerHTML equals this.loadingContentTarget.innerHTML. So it's going to copy whatever we've defined as our loading content into our dynamic content. Finally, let's add that target. So in base.html.twig, after my dialog, I'll add a template element. Yes, my beloved template element. It's perfect for this situation because anything inside of a template element isn't visible on the page. Let's add a data modal target equals loading content. And then inside of this, we're going to add a template element that we're going to And then inside of this, I'm going to paste in some content. This is just some tailwind classes that are going to give us this nice pulsing animation. Now, if we tried this right now, it still doesn't work because nothing is calling our new show loading method. And this is where we can use a little trick from a turbo. So over in base.html.twig, find the iframe. I'm going to move this on to multiple lines. What we effectively want to do is the moment the turbo frame starts loading, we want the loading content to show. And turbo dispatches an event when it starts an AJAX request that we can listen to. So add a data action to listen to that and we'll say turbo before fetch request. That's the name of the event. Then arrow modal pound sign show loading. All right, let's check out the effect here. I'm going to refresh the page and, oh, I love that opens instantly. We see that loading content. It's perfect.  And it's really cool how it works. When this calls show loading, show loading puts content into our dynamic content target. And do you remember what happens? The moment any content goes into a turbo frame that triggers the modal to open. So there's some really cool teamwork going on here to get that modal to open immediately. And then once the turbo frame actually finishes loading, its final content overrides the loading. All right, so we're almost there to making this perfect, but I'm not satisfied yet. And while I have that sleep in there, I'm going to hit save. Look it, nothing happens. There's no feedback while that's loading. Fortunately, that's easy to fix, and we've already done it on a different turbo frame. I'm going to add class area-busy colon opacity 50, and then transition opacity. This time, let's reload this. Actually, I should reload the page. There we go. And we've got the nice loading animation. And yes, we get the low animation. Low opacity, so we can see that it's doing something. All right, so with that, I will happily remove our sleep. At this point, there's just one last detail I want to talk about, and it's this extra padding here. The reason that extra padding is there is because we're going to be using it to edit the page. So the reason that extra padding is there is because the content from the page has an M4 and a P4 that adds that. So the modal has some padding, and then there's extra padding coming from that on the page. And on the page, that margin and padding makes sense. So this comes from over here in new.html-twig. And when that same content is inside of the modal, we want that to hide. So to help us do this, we're going to add, we're going to use a tailwind trick. So it's really easy for us to customize this. So in tailwind.config.js, let's add one more variant. We're going to call this one modal, and it's going to activate whenever we are inside of a dialog element. Thanks to that, over in new.html-twig, we'll keep the margin for and the padding for in normal situations. But if we're in a modal, use M0, and if we're in a modal, use P0.  All right, so over here on this page, there shouldn't be any change. That looks good. But now, oh, look at that. That is the modal padding and margin we want. So that's it. With a fully reusable modal system, it loads instantly, it submits into it, and it even closes itself when the modal, when the content disappears. Watch. First voyage from a modal. And I'll choose this. Let's close this for dramatic effect and save. Look at that. It closed. How? The new action redirects to the index page, and the index page doesn't extend modal base. It extends the normal base.html-twig. So there is a modal frame on the index page, but it's the empty frame at the bottom of the page. So that means that the modal lost its content. What happens when the modal loses its content? The modal is smart enough to close itself. Now, the only thing we are missing, if you're watching closely, is there is no toast notification. So tomorrow, we'll talk all about handling form success when a form is submitted inside a frame. By the end, we're even going to move the edit into a modal and add a few other effects that are simply amazing.
