# Testing Twig & Live Components

Coming soon...

All these cool things we've been building are just goodies, unless we can properly test them. So, that's today's mission. We've got lots to do, so let's get started. Run composer-require phpunit. That will install the Symfony test pack, which will give us all the packages we need and make sure they're in our required dev. The first thing I'm going to test is a Twig component. This is a pretty cool thing. You can actually test how a Twig component is created. You can call methods on it, and you can even assert how it's rendered. So, we're going to start by testing the Button component, even though it's pretty simple. So, in the test directory, I'm going to create an integration directory, because this is going to be an integration test, and then twig slash components. If you want to know more about integration testing, you can check out our tutorial on that. Inside of that directory, create a new Button test class, and we'll extend the normal kernel test case for integration tests. Now, to help us work with our Button, we're going to use a trait called useInteractsWithTwigComponents. That will create a new function called testButtonRendersWithVariants. This trait gives us basically two new methods. The first one is going to be a way to create our component. So, we can say this arrow, mountTwigComponents, and then we can pass it the normal arguments that we would to create that. So, its name is Button, and we can pass variant set to success. What this should give us, I'll check it here, assertInstanceOfButtonClassComponent, should give us an instance of our component. So, behind the scenes, it should instantiate our components, populate the properties, and if our component auto-wires services, it'll take care of all of that. It's the exact same process it uses to normally create it in our real app. So, let me dump this component, and then I'm going to say assertSame that variant, that success, is equal to component arrow variant. Cool. So, to run this, let's run Vendor, Bin, SimplePHPUnit, Tests, Integration. It'll download PHPUnit, and it passes. So, we have some deprecation notices down here we'll ignore, but check it out. It actually gives us our button object, which is cool. So, the second thing we can do is render a component. So, I'll copy the top here, down on the bottom.  I'll paste, rename this to Rendered, and we'll say, RenderToyComponent. This has almost the same arguments, except now we can pass blocks, and the third argument's an easy way to pass a content block. So, I'll pass a content block that even contains a span, and then below this, we'll dump Rendered. And we run it. Awesome. So, it gives us an object which has the HTML inside. And with this, you could just get the actual string by saying, Rendered arrow to string, or it also gives you a crawler object. So, you can say cool things like, this arrow assert same, that click me, is equal to Rendered arrow crawler, arrow filter to find the span, and then arrow text to get the text node. Pretty sweet. And my editor does think there's a problem syntax error here. There's not. It's crazy. And the test passes. All right. So, what about integration testing a live component? So, let me close this. We're going to work on our SearchSiteComponent. So, in the same directory, I'm going to create a new class called SearchSiteTest, and it's going to extend integration kernel test case. And this time, we will use interacts with live components, and I'll create a new function called TestCanRenderAndReload. This time, I'll say TestComponent equals, and this is a different method to help us. It's called CreateLiveComponents, and then we pass the name, SearchSite. And I can also pass props here, but notice I'm not passing props here, but I'm not going to do that. Then we'll dd TestComponent over here. Now, when we run this, the object's going to be humongous, but it dumps this cool TestLiveComponent object. And this has lots of goodies on it for interacting. We can say TestComponent arrow component to get the underlying object. We can render it. We can set properties on it. We can call live actions on it. We can emit events. We can log in as users. Lots of really cool stuff. So to really properly test our search here, we're going to need some voyages in the database. So on top, I'm going to use ResetDatabase and use Factories. Then down here, I use VoyageFactoryCreateMany to create five voyages, and I'm going to give them all the same purpose so we can search for them easily.  First five voyages, and then I'll call VoyageFactoryCreateOne to create one other voyage that will have some other purpose. Now if we run this right now, we're going to hit a database problem. It's having problems connecting to our database, which is running in Docker. I'm not going to go too deep into the reason we have ... I'm not going to go too deep into this. The way to fix this is by running Symfony PHP. That allows it to inject the database underscore URL environment variable into our test. And now when we run it, awesome. We're back. We have one risky test because we don't have any assertions, but it's not exploding. So let's do some assertions. Now remember, by default, if there is no query, which we shouldn't have one by default, it returns an empty result set. And in the templates for this, templates, components, search site, when we do have results, we render them inside of an A tag. It's the only A tag in this template. So here I'm going to say this arrow assert count, that zero is equal to test component, arrow render, and then we can use that same crawler to filter for A tags. Here's the really cool part. We can then say test component, arrow set query, first five, so we can change the property mimicking the user typing into the search box, and now we should have five results. Let's try it.
