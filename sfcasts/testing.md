# Functional Testing

Coming soon...

It works! Okay, let's move on to the final and biggest tool for testing. That's going to be functional or end-to-end testing, where we programmatically control a browser, have it click links, and fill out forms. We're going to get an awesome setup, but I've got to admit, this takes way too much work, and it's something that we need to improve. So the library I like to use for functional testing is Zenstruck Browser. Run composer.require zenstruck-browser-dev. And then I'm going to bootstrap a functional test. So in the test directory, I'll create a directory called Functional. And inside of there, I'll create a new PHP class called VoyageControllerTest. And I guess I could create a controller directory also. And inside, I'm just going to paste over. Now what I want you to notice is we are using ResetDatabase and Factories. It extends the normal web test case. And then this has Browser comes from the Browser library, and it gives us the ability to call Browser and then use this really cool syntax for clicking through the site and filling out fields. So the flow we're going through here is the one that clicks voyages, clicks a new voyage, fills out the form, clicks save, and then we assert some results in the bottom. We're starting with a single voyage in the database. So after we create a new one, we're asserting that we see two voyages on the page. Now to run this, we're going to use the same command, but this time I'll target the Functional directory. And it actually passes, which is awesome. However, there's no JavaScript. And behind the scenes, it used a fake browser to do those things. If we want to test with JavaScript, we can by saying this AeroPanther browser. We're not going to see it, but that's going to cause a real browser like Chrome to run in the background, and it will actually execute JavaScript. However, when we try it, the first thing it's going to tell us is, hey, you need to install a Symfony slash Panther. So let's do that. Composer require Symfony slash Panther dash dash dev. And if we tried it now, it would tell us one other thing, and that's that we need to extend a Panther test case. All right. So if we try it now, it fails actually pretty early.  It says clickable element new voyage not found. So it didn't get very far. It clicked on voyages, but it didn't find the new voyage. And one of the cool things with browser when it's used with Panther is that it automatically takes a screenshot of the failure. So we can check it out inside the var directory and check it out. It's still on the first page. It's as if it never clicked voyages, though you can kind of see that voyages was clicked. So the problem is that because all of our page loads are happening via Ajax, our tests aren't waiting for them. It's just clicking voyages, then immediately trying to click new voyage. So that's gonna be the main thing we're gonna have to fix. But before that, it's kind of a bigger problem. Look at the data here. This is not coming from our test database. This is coming from our live. This is coming from our dev site. So Panther detected that we're using the Symfony web server, and instead of booting up a... Remember, Panther uses a real browser behind the scenes to make requests. It actually needs a real web server running. It detected that when we have one running and just use ours automatically. It's actually not what we want. I wanted to spin up a new web server that runs in the test environment so that it's pulling from the test database. To do that, open up phpunit.xml.dist, and I'm gonna paste in two environment variables. So the first, I think, is kind of a workaround. That tells Panther to not use our server. And the second one says, hey, when you do start your own web server, start it in the test environment. And then over in our controller, to make it even easier to find the screenshot, after we click voyages, I'm gonna do a DD screenshot, dump and die, take a screenshot, then dump and die. So it runs, it hits our DD, and it tells us where it saves the screenshot, which is cool. So it's over here in var. Browser, there's the screenshot. And okay, it's working, but it's missing all the styles. To help debug this, we can temporarily have that browser really open. So check this out. After we visit, I'm gonna say pause.  And then to get this to open the browser, I'm gonna add an environment variable called panther no headless equals one. Check this out. Boom. It fires open in a real browser. And then freezes. So now we can view the page source. Here's our CSS file. I'll open that. And it's a 404 not found. Why? Panther starts a web server using the PHP, the built-in PHP web server. And by default, and the way these assets work in the dev environment is they need to get proxied through symphony. So we need a rewrite rule that tells it to send these URLs through symphony. So it's kind of an annoying detail, honestly. So back to my terminal, I'll hit enter to close that. Now go back over here. And we're going to add a custom router in the tests directory. Create a new file called router.php. This is not a detail I want to have to worry about, but here we are. And I'll paste in the guts. This little code here fixes that problem. To tell Panther to use it in phpunit.xml.disk, it's one more environment variable, which I will paste in called panther-webserver-router with value equals dot dot slash tests. Well, it's relative to the slash router.php. It's relative to the public directory. And now it works. Love that. All right, I'll hit enter to have that continue. Perfect. So let's get rid of our pause. And now we're going to go ahead and create a new file called panther-webserver-router. So let's get rid of our pause. And I'll run the test one more time. I'll run the test again. Oh, sorry, my bad. Run the test again, but this time without the Panther headless. Cool. It hit our screenshot. Let's pop that open. And awesome. Cool. So you can see it is on the second page, which is fantastic. And though you can't see it here, a lot of times on these pages, I don't know. All right. No, it's the same problem we originally had. It's not waiting for the page to load. So this isn't going to be a problem because we need to wait for the AJAX call to finish. There's not an easy way to do that right now. I want to show you how you can do it. I'm going to say browser equals.  We'll close this off. I'm going to say browser down here. And in between, I'm going to paste in two lines of code. This is a little lower level, but it's going to wait for the area busy to get added to the HTML element. Then it's going to wait for that to go away. So I run the test again. Let's open our screenshot and interesting. So this is really cool. It is now waiting for the page load to happen. But remember, we also have view transition. So even though the page is loaded, there's still this view transition happening. So that is something we are going to worry about in a second. But before we do, we got to clean this up because I cannot have code that looks like this everywhere. This is way too much work to wait for the page load. So we're going to create a custom browser object. In the test directory, create a new piece of class. Let's call it app browser. This is going to extend. I'll add the namespace, which is mysteriously missing. And I'm going to paste that in. Notice it extends the normal pan the browser, and it adds a new method, which has those lines in it, which is cool. Our goal is that when we call pan the browser here, it's going to give us an instance of our app browser instead of the normal one. And to do that, it is one more environment variable called Panther browser class. And to make sure this is working, I am going to DD get class on the browser. So when we run that test, yes, awesome. So we can see we are getting our app browser. Unfortunately, we don't get autocomplete on that new method because our editor still thinks that Panther browser is returning the core Panther browser. So to get around this, we're going to do one last thing, which is create a custom base test class. So in that test directory, again, create a new class called app Panther test case.

And I'll paste in the contents here as well. It extends the normal Panther test case, and all it does is override the Panther browser method called the parent one, but then it changes the return type so that we know that this is our app browser. So over in VoyageControllerTest, we'll change this to ExtendAppPantherTestCase, then make sure you get rid of the UseHasBrowser, and then we can tighten things up down here. We can reconnect all of these spots, and then use that, wait for page loaded, auto-complete, it's beautiful. All right, let's move this DD and see where we are. We're clicking Voyages, we're waiting for the page to load, let's try it. And okay, further look, now it says form field with purpose not found. So it clicked Voyages, it clicked New Voyage, it didn't find the form field. If you look down here in error screenshots, you can see why. It's still loading. For you, if you try this, you might see the form, because it might have loaded right before the screenshot was taken, but this is in fact the problem. Oh, and you know what, before we fix this, oh, and you know what, before we fix this, one other thing that I wanna get done before it bites us is in Templates, base.html twig. Remember the view transition that was happening? Let's get rid of that in the test environment by saying if app.environment does not equal test. That's just gonna get that out of the way so it doesn't cause problems. It's also gonna make our test run a little bit faster, because we don't have to wait for those. Anyway, back to our failure. When we click to open the modal, what we really need to do is wait for the modal to open, it already is, but we can do that just in case, and then we need to wait for the turbo frame inside of it to finish loading. To that, in App Browser, I'm gonna paste in two more methods here.  First one's called waitForDialog, and it just waits until it sees a dialog on the page with an open attribute, and the second says, okay, if that open dialog has a turbo frame, then wait for the turbo frame to load, which means wait until there, make sure there aren't any area busy turbo frames on the page. So in VoyageControllerTest, after clicking new Voyage, we'll say waitForDialog, and now, oh so close, check this out, table tbodytr expected two elements on the page, but only found one. That's coming from all the way down here, so we're really, really close. What's the problem this time? We'll go back to our error screenshots, and ah. We filled out the form, it looks like we even hit save, we're just checking, we're just doing the assertion too quickly. Remember, we're submitting it to a turbo frame, so we need to wait for that turbo frame to finish loading. And now we have a way to do this, so we can say waitForTurboFrameLoad, and then I'm also gonna add a little extra little thing here that says assert not C element, dialog open, to make sure that the dialog actually finished closing. And now finally, run it one more time. It passes. Okay, as I mentioned, especially with the functional testing, now that we have it set up, it's going to work great. It was too much to set up, something that we need to improve on. Tomorrow, we're gonna talk about performance, which unlike testing, is gonna come together way more automatically.

